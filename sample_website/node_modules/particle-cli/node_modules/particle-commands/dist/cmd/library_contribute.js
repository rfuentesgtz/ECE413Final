'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LibraryContributeCommand = exports.LibraryContributeCommandSite = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _command = require('./command');

var _particleLibraryManager = require('particle-library-manager');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 */
var LibraryContributeCommandSite = exports.LibraryContributeCommandSite = function (_CommandSite) {
	_inherits(LibraryContributeCommandSite, _CommandSite);

	function LibraryContributeCommandSite() {
		_classCallCheck(this, LibraryContributeCommandSite);

		return _possibleConstructorReturn(this, (LibraryContributeCommandSite.__proto__ || Object.getPrototypeOf(LibraryContributeCommandSite)).call(this));
	}

	_createClass(LibraryContributeCommandSite, [{
		key: 'apiClient',
		value: function apiClient() {
			throw new Error('apiClient not available');
		}
	}, {
		key: 'dryRun',
		value: function dryRun() {
			return false;
		}
	}, {
		key: 'libraryDirectory',
		value: function libraryDirectory() {
			throw Error('not implemented');
		}

		// validationError(err) - optional method

	}, {
		key: 'error',
		value: function error(err) {
			throw err;
		}

		/**
   * Notification that the library directory is being checked. The library is validated and then loaded.
   * @param {Promise} promise     The promise to validate the library
   * @param {string} directory    The directory that contains the library to validate
   */

	}, {
		key: 'validatingLibrary',
		value: function validatingLibrary(promise, directory) {}

		/**
   * Notification that library contribution is starting
   * @param {Promise} promise   The promise that will contribute the library.
   * @param {Library} library   The loaded library
   */

	}, {
		key: 'contributingLibrary',
		value: function contributingLibrary(promise, library) {}

		/**
   * Notification that the library has been successfully contributed.
   * @param {Library} library the library that was contributed.
   */

	}, {
		key: 'contributeComplete',
		value: function contributeComplete(library) {}
	}]);

	return LibraryContributeCommandSite;
}(_command.CommandSite);

/**
 * Implements the library contribute command.
 */


var LibraryContributeCommand = exports.LibraryContributeCommand = function (_Command) {
	_inherits(LibraryContributeCommand, _Command);

	function LibraryContributeCommand() {
		_classCallCheck(this, LibraryContributeCommand);

		return _possibleConstructorReturn(this, (LibraryContributeCommand.__proto__ || Object.getPrototypeOf(LibraryContributeCommand)).apply(this, arguments));
	}

	_createClass(LibraryContributeCommand, [{
		key: 'run',


		/**
   * @param {object} state The current conversation state.
   * @param {LibraryContributeCommandSite} site external services.
   * @returns {Promise} To run the library contribute command.
   */
		value: function run(state, site) {
			var events = function events(event) {
				for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
				}

				var fn = site[event].bind(site) || function () {};
				fn.apply(undefined, args);
			};

			var name = '';
			var dryRun = false;
			var contributeDir = void 0;
			return Promise.resolve(site.libraryDirectory()).then(function (dir) {
				contributeDir = dir;
				return site.dryRun();
			}).then(function (d) {
				return dryRun = d;
			}).then(function () {
				return site.apiClient();
			}).then(function (client) {
				var repo = new _particleLibraryManager.FileSystemLibraryRepository(contributeDir, _particleLibraryManager.FileSystemNamingStrategy.DIRECT);
				return repo.contribute(name, client, dryRun, events);
			}).catch(function (err) {
				if (err.validate && site.validationError) {
					site.validationError(err);
				} else {
					site.error(err);
				}
			});
		}
	}]);

	return LibraryContributeCommand;
}(_command.Command);