'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LibraryInitCommand = exports.LibraryInitCommandSite = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _command = require('./command');

var _particleLibraryManager = require('particle-library-manager');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var promisify = require('es6-promisify');

/**
 * Specification and base implementation for the site instance expected by
 * the LibraryInitCommand.
 */

var LibraryInitCommandSite = exports.LibraryInitCommandSite = function (_CommandSite) {
	_inherits(LibraryInitCommandSite, _CommandSite);

	function LibraryInitCommandSite() {
		_classCallCheck(this, LibraryInitCommandSite);

		return _possibleConstructorReturn(this, (LibraryInitCommandSite.__proto__ || Object.getPrototypeOf(LibraryInitCommandSite)).call(this));
	}

	_createClass(LibraryInitCommandSite, [{
		key: 'yeomanAdapter',
		value: function yeomanAdapter() {
			throw new Error('not implemented');
		}
	}, {
		key: 'yeomanEnvironment',
		value: function yeomanEnvironment() {
			throw new Error('not implemented');
		}
	}, {
		key: 'options',
		value: function options() {
			return {};
		}
	}, {
		key: 'args',
		value: function args() {
			return [];
		}
	}]);

	return LibraryInitCommandSite;
}(_command.CommandSite);

/**
 * Implements the library initialization command.
 */


var LibraryInitCommand = exports.LibraryInitCommand = function (_Command) {
	_inherits(LibraryInitCommand, _Command);

	function LibraryInitCommand() {
		_classCallCheck(this, LibraryInitCommand);

		return _possibleConstructorReturn(this, (LibraryInitCommand.__proto__ || Object.getPrototypeOf(LibraryInitCommand)).apply(this, arguments));
	}

	_createClass(LibraryInitCommand, [{
		key: 'generatorClass',
		value: function generatorClass() {
			return (0, _particleLibraryManager.buildLibraryInitGeneratorClass)();
		}

		/**
   *
   * @param {object} state The current conversation state.
   * @param {LibraryInitCommandSite} site external services.
   * @returns {Promise} To run the library initialization command.
   */

	}, {
		key: 'run',
		value: function run(state, site) {
			var yeoman = site.yeomanEnvironment();
			var args = site.args();
			var opts = site.options();
			var env = yeoman.createEnv(args, opts, site.yeomanAdapter());
			env.registerStub(this.generatorClass(), 'library:init');
			var run = promisify(function () {
				return env.run.apply(env, arguments);
			});
			return run(['library:init'], opts);

			// we ideally want the instance so that we can hook the 'end' event
			// yeoman-evironment doesn't provide the instance with the registration method above
			// so we dive below the covers and do it ourselves...
			// const generator = env.instantiate(LibraryInitGenerator, opts);
			// return new Promise((fulfill, reject) => {
			// 	generator.on('end', fulfill);
			// 	generator.on('error', reject);
			// 	generator.run();
			// });
		}
	}]);

	return LibraryInitCommand;
}(_command.Command);