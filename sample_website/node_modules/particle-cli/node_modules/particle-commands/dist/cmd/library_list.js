'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LibraryListCommand = exports.LibraryListCommandSite = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _command = require('./command');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Specification and base implementation for the site instance expected by
 * the LibraryInstallCommand.
 */
var LibraryListCommandSite = exports.LibraryListCommandSite = function (_CommandSite) {
	_inherits(LibraryListCommandSite, _CommandSite);

	function LibraryListCommandSite() {
		_classCallCheck(this, LibraryListCommandSite);

		return _possibleConstructorReturn(this, (LibraryListCommandSite.__proto__ || Object.getPrototypeOf(LibraryListCommandSite)).call(this));
	}

	/**
  * Retrieves an object which describes the library sections to list
  * The returned object has a property for each section defining attributes for that section.
  * The sections are:
  * official: official libraries
  * verified: verified third party libraries
  * featured: featured libraries - libraries to draw user's attention to
  * popular: libraries that don't fall into the categories above, sorted by most popular first
  * mine: user's current libraries
  * recent: recently updated libraries
  * community: not-my libraries sorted by official, verified, popularity and then name
  *
  * The value of each section is an object:
  * ```
  * {
  *    page: Number  // page to retrieve
  *    limit: Number // the size of each page
  *    sort: String  // override the default sort order for this section. Values are
  *      [-]name, installs, date
  *    architectures: String  // comma-separated list of architectures, or * for all
  *    filter: String   // text filter to apply to the list of names
  * }
  * ```
  */


	_createClass(LibraryListCommandSite, [{
		key: 'sections',
		value: function sections() {
			throw new Error('not implemented');
		}

		/**
   * Retrieves the default settings:
   * {
   *    sort: String; default sort order
   *    page: Number; default page to retrieve
   *    limit: Number; default page size
   *    filter: String; default name filter
   *    architectures: String; comma-separated list of architectures to filter on
   * }
   */

	}, {
		key: 'settings',
		value: function settings() {
			throw Error('not implemented');
		}

		/**
   * The object in which to store the results.
   */

	}, {
		key: 'target',
		value: function target() {
			throw Error('not implemented');
		}
	}, {
		key: 'apiClient',
		value: function apiClient() {
			throw new Error('not implemented');
		}

		/**
   * Notification of a promise to fetch a given library list. The result of the promise is the list of libraries.
   * NB: Currently unused.
   * @param {Promise} promise   The promise to fetch the list of libraries
   * @param {String} name      The configuration name
   * @param {Object} settings  The final settings for fetching the list
   * @return {Promise|undefined} either a new promise (wrapping the original promise) or
   * undefined to use the original unmodified.
   */

	}, {
		key: 'notifyFetchList',
		value: function notifyFetchList(promise, name, settings) {
			return undefined;
		}

		/**
   * Notification that all the lists are being fetched. The result of the promise is an object, with each
   * list keyed by the name of the list.
   * @param {Promise} promise   The promise to fetch all library lists
   * @param {Object} settings  The settings used to fetch each list
   */

	}, {
		key: 'notifyFetchLists',
		value: function notifyFetchLists(promise, settings) {}
	}, {
		key: 'error',
		value: function error(err) {
			throw err;
		}
	}]);

	return LibraryListCommandSite;
}(_command.CommandSite);

/**
 * Implements the library list command.
 * It populates various library lists with library instances based on the
 * query provided by the site.
 */


var LibraryListCommand = exports.LibraryListCommand = function (_Command) {
	_inherits(LibraryListCommand, _Command);

	function LibraryListCommand() {
		_classCallCheck(this, LibraryListCommand);

		var _this2 = _possibleConstructorReturn(this, (LibraryListCommand.__proto__ || Object.getPrototypeOf(LibraryListCommand)).call(this));

		_this2.categories = {
			official: _this2._makeCategory('official'),
			verified: _this2._makeCategory('verified', 'official'),
			featured: _this2._makeCategory('featured'),
			popular: _this2._makeCategory('public', 'verified,official'),
			mine: _this2._makeCategory('mine', undefined, 'name'),
			recent: _this2._makeCategory('all', undefined, '-date'),
			community: _this2._makeCategory('all', 'mine', 'official,verified,popularity,name')
		};
		return _this2;
	}

	_createClass(LibraryListCommand, [{
		key: '_makeCategory',
		value: function _makeCategory(scope, excludeScope, sort) {
			return { scope: scope, excludeScope: excludeScope, sort: sort };
		}

		/**
   * @param {object} state The current conversation state.
   * @param {LibraryListCommandSite} site external services.
   * @returns {Promise} To run the library list command.
   */

	}, {
		key: 'run',
		value: function run(state, site) {
			var _this3 = this;

			var client = void 0,
			    settings = void 0,
			    sections = void 0,
			    config = void 0,
			    target = void 0;

			var result = Promise.resolve().then(function () {
				return site.apiClient();
			}).then(function (_client) {
				client = _client;
				return site.settings();
			}).then(function (_settings) {
				settings = _settings;
				return site.sections();
			}).then(function (_sections) {
				sections = _sections;
				return site.target();
			}).then(function (_target) {
				target = _target;
				config = _this3.normalizeConfig(settings, sections);
				return _this3.fetchLists(site, client, config, target);
			}).catch(function (err) {
				return site.error(err);
			});
			return result;
		}
	}, {
		key: 'fetchLists',
		value: function fetchLists(site, client, config, target) {
			var fetch = this._buildFetchLists(site, client, config, target);
			return this._buildNotifyFetchPromise(site, fetch, config, target);
		}
	}, {
		key: '_buildFetchLists',
		value: function _buildFetchLists(site, client, config, target) {
			var fetch = [];
			for (var name in config) {
				var settings = config[name];
				var list = this.fetchList(site, client, name, settings, target);
				fetch.push(list);
			}
			return fetch;
		}
	}, {
		key: '_buildFetchPromise',
		value: function _buildFetchPromise(site, fetch, target) {
			return Promise.resolve().then(function () {
				return Promise.all(fetch);
			}).then(function (result) {
				return target || result;
			});
		}
	}, {
		key: '_buildNotifyFetchPromise',
		value: function _buildNotifyFetchPromise(site, fetch, config, target) {
			var all = this._buildFetchPromise(site, fetch, target);
			all = site.notifyFetchLists(all, config) || all;
			return all;
		}
	}, {
		key: '_addResultToTarget',
		value: function _addResultToTarget(list, name, target) {
			return list.then(function (libraries) {
				if (target) {
					target[name] = libraries;
					return target;
				}
				return libraries;
			});
		}
	}, {
		key: 'fetchList',
		value: function fetchList(site, client, name, settings, target) {
			var list = client.libraries(settings);
			list = this._addResultToTarget(list, name, target);
			list = site.notifyFetchList(list, name, settings) || list;
			return list;
		}
	}, {
		key: '_removeUndefined',
		value: function _removeUndefined(value) {
			for (var name in value) {
				if (value[name] === undefined) {
					delete value[name];
				}
			}
			return value;
		}
	}, {
		key: 'normalizeConfig',
		value: function normalizeConfig(base, settings) {
			var config = {};
			for (var name in settings) {
				config[name] = this._removeUndefined(Object.assign({}, this.categories[name], base, settings[name]));
			}
			return config;
		}
	}]);

	return LibraryListCommand;
}(_command.Command);