'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Analytics = require('analytics-node');
var promisify = require('es6-promisify');
var _ = require('lodash');

var pipeline = require('when/pipeline');

var CommandContext = function () {
	function CommandContext() {
		_classCallCheck(this, CommandContext);
	}

	_createClass(CommandContext, [{
		key: 'identifyUser',
		value: function identifyUser(particleApiClient) {
			if (particleApiClient.ready()) {
				return particleApiClient.trackingIdentity();
			} else {
				return Promise.reject();
			}
		}

		/**
   * Determine if the given user descriptor has the requisite identification for a tracking request.
   * @param {object} user The user object to check.
   * @returns {boolean}   true if the identity contains the requisite fields (id, email)
   */

	}, {
		key: 'isIdentity',
		value: function isIdentity(user) {
			return Boolean(user && user.id && user.email);
		}

		/**
   * Retrieves the tracking details for the current logged in user.
   * @param {function(newValue)} trackingIdentity a fetch-update function for the cached tracking identity for the
   *  current profile.
   * @param {object} apiClient    The API Client that provides the tracking identity via "
   * @param {function(opts)} clientFactory synchronously create a client
   * @return {Promise<object>} promise to retrieve the tracking identity
   */

	}, {
		key: 'trackingUser',
		value: function trackingUser(trackingIdentity, apiClient) {
			var _this = this;

			var ident = trackingIdentity();
			if (this.isIdentity(ident)) {
				return Promise.resolve(ident);
			} else {
				return this.identifyUser(apiClient).then(function (user) {
					if (_this.isIdentity(user)) {
						trackingIdentity(user);
						return user;
					} else {
						return null;
					}
				});
			}
		}
	}, {
		key: 'buildContext',
		value: function buildContext(_ref) {
			var _this2 = this;

			var tool = _ref.tool,
			    api = _ref.api,
			    trackingIdentity = _ref.trackingIdentity,
			    apiClient = _ref.apiClient;

			// todo - allow the API key to be overridden in the environment so that CLI use during development/testing
			// is tracked against a distinct source
			return pipeline([function () {
				return _this2.trackingUser(trackingIdentity, apiClient);
			}, function (user) {
				return {
					user: user,
					tool: tool,
					api: api
				};
			}]);
		}
	}]);

	return CommandContext;
}();

var test = {
	CommandContext: CommandContext
};

/**
 *
 * @param {object} tool      The tool definition { name, version }
 * @param {object} api       The tracking api details { key }
 * @param {function(newValue)} trackingIdentity function to retrieve or update the cached user identity
 * @param {object} apiClient   The Particle api client that provides a `trackingIdentity` method.
 * @returns {Promise<object>} promise to build the command context object containing the tool, api and user attributes.
 */
function buildContext(_ref2) {
	var tool = _ref2.tool,
	    api = _ref2.api,
	    trackingIdentity = _ref2.trackingIdentity,
	    apiClient = _ref2.apiClient;

	return new CommandContext().buildContext({ tool: tool, api: api, trackingIdentity: trackingIdentity, apiClient: apiClient });
}

/**
 * Provides command oriented tracking for analytics. This establishes a convention for how
 * the calling tool specifies the user, any user traits, the tool name, event date time.
 */

var analyticsCache = {};

function analyticsFor(key) {
	var analytics = analyticsCache[key];
	if (!analytics) {
		analytics = new Analytics(key, { flushAfter: 10 });
		analyticsCache[key] = analytics;
	}
	return analytics;
}

function buildProperties(context, properties) {
	var tool = _.mapKeys(context.tool || {}, function (value, key) {
		return 'tool' + key;
	});
	return Object.assign(properties, tool);
}

function checkApiKey(context) {
	if (!context || !context.api || !context.api.key) {
		throw new Error('context.api.key not provided'); // todo - distinguish programming/caller errors from runtime errors?
	}
	return context.api.key;
}

function checkUserId(context) {
	var userId = context && context.user && context.user.id;
	var track = context && context.user && context.user.track;
	if (!userId && track !== false) {
		throw new Error('context.user.id not provided'); // todo - distinguish programming/caller errors from runtime errors?
	}
	return userId;
}

function makeAnalytics(context) {
	var key = checkApiKey(context);
	return analyticsFor(key);
}

/**
 *
 * @param {Command} command     The command being executed. May be null for tracking events outside of a command
 * execution context.
 * @param {Object} context      The command invocation context. The analytics property should contain
 * {tool, user, api}.  The api property should include `key` as a minimum, to specify the Segment write key.
 *  THe tool object must contain at least a `name` property to identify the tool being used. User traits must include
 *  at least `id` and `name` properties, which are opaque and natural keys used to identify the current user.
 *  If userTraits is falsey the event is logged anonymously.
 * @param {CommandSite} site     The command site. This is presently unused but may be later used for context-specific
 *      functionality.
 * @param {String}  event       The event name to track.
 * @param {Object}  properties      Additional data to log with the event.
 * @return {Promise} promise to track
 */
function track(_ref3) {
	var command = _ref3.command,
	    context = _ref3.context,
	    site = _ref3.site,
	    event = _ref3.event,
	    properties = _ref3.properties;

	var userId = checkUserId(context);
	if (!userId) {
		return Promise.resolve();
	}
	var analytics = makeAnalytics(context);
	var allProperties = buildProperties(context, properties);

	var track = promisify(analytics.track, { thisArg: analytics });
	return track({
		userId: userId,
		event: event,
		allProperties: allProperties
	});
}

function identify(_ref4) {
	var command = _ref4.command,
	    context = _ref4.context,
	    site = _ref4.site,
	    traits = _ref4.traits;

	var analytics = makeAnalytics(context);
	var userId = checkUserId(context);
	var identify = promisify(analytics.identify, { thisArg: analytics });
	return identify({
		userId: userId,
		traits: traits
	});
}

/**
 * Ensure that any events have been sent. Returns a promise.
 * @return {Promise} to eventually flush
 */
function flush() {
	return Promise.resolve();
}

exports.identify = identify;
exports.track = track;
exports.flush = flush;
exports.buildProperties = buildProperties;
exports.buildContext = buildContext;
exports.test = test;