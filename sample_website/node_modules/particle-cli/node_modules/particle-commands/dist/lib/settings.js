'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require('path');
var _ = require('underscore');
var utilities = require('./utilities');
var fs = require('fs');

var Settings = function () {
	function Settings() {
		var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
		    _ref$separateSettings = _ref.separateSettings,
		    separateSettings = _ref$separateSettings === undefined ? true : _ref$separateSettings,
		    _ref$settings = _ref.settings,
		    settings = _ref$settings === undefined ? [] : _ref$settings;

		_classCallCheck(this, Settings);

		this.settings = separateSettings ? {} : this; // current configuration settings
		this.profile = null; // current profile name
		this.profile_json = {}; // parsed contents of profile.json
		this.overrides = {}; // current overrides from the profile config file
		settings.unshift(this.settings); // add target as first argument
		_.extend.apply(_, settings);
	}

	_createClass(Settings, [{
		key: 'get',
		value: function get(name) {
			return name === undefined ? this.settings : this.settings[name];
		}
	}, {
		key: 'set',
		value: function set(key, value) {
			return this.override(null, key, value);
		}

		/**
   * Retrieve a value from the environment
   * @param {string} varName  The name of the environment variable to retrieve
   * @param {string} defaultValue The value to return when the environment variable is not defined
   * @return {string} the value of the environment, or defaultValue if not defined
   */

	}, {
		key: 'envValue',
		value: function envValue(varName, defaultValue) {
			var value = process.env[varName];
			return typeof value === 'undefined' ? defaultValue : value;
		}

		/**
   * Fetches the value of an environment varaible interpreted as a boolean
   * @param {string} varName       The environment variable name
   * @param {string} defaultValue     The default boolean value to return when the environment
   *  variable is not defined ir is not recognized as a boolean
   * @returns {boolean} The value of the environment variable when defined. defaultValue when not defined, or not
   *  one of true, TRUE, 1, false, FALSE, 0
   */

	}, {
		key: 'envValueBoolean',
		value: function envValueBoolean(varName, defaultValue) {
			var value = this.envValue(varName);
			if (value === 'true' || value === 'TRUE' || value === '1') {
				return true;
			} else if (value === 'false' || value === 'FALSE' || value === '0') {
				return false;
			} else {
				return defaultValue;
			}
		}

		/**
   * Determine the user home path from the environment
   * @returns {string}    The home path of the current user, or
   *  the directory containing this file if it could not be determined.
   */

	}, {
		key: 'findHomePath',
		value: function findHomePath() {
			var fs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : require('fs');

			var envVars = ['home', 'HOME', 'HOMEPATH', 'USERPROFILE'];

			for (var i = 0; i < envVars.length; i++) {
				var dir = this.envValue(envVars[i]);
				if (dir && fs.existsSync(dir)) {
					return dir;
				}
			}
			return __dirname;
		}

		/**
   * Ensures that the particle folder in the home directory exists.
   * @returns {string}    The location of the particle folder.
   */

	}, {
		key: 'ensureFolder',
		value: function ensureFolder() {
			var particleDir = path.join(this.findHomePath(), '.particle');
			if (!fs.existsSync(particleDir)) {
				fs.mkdirSync(particleDir);
			}
			return particleDir;
		}

		/**
   * Determine the location of a given profile configuratino file
   * @param {string} profile      The name of the profile
   * @returns {string} the path of the overrides file
   */

	}, {
		key: 'findOverridesFile',
		value: function findOverridesFile(profile) {
			profile = this.defaultProfile(profile);
			var particleDir = this.ensureFolder();
			return path.join(particleDir, profile + '.config.json');
		}
	}, {
		key: 'defaultProfile',
		value: function defaultProfile(profile) {
			return profile || this.profile || 'particle';
		}
	}, {
		key: 'loadOverrides',
		value: function loadOverrides(profile) {
			profile = this.defaultProfile(profile);

			var filename = this.findOverridesFile(profile);
			try {
				if (fs.existsSync(filename)) {
					this.overrides = JSON.parse(fs.readFileSync(filename));
					// need to do an in-situ extend since external clients may have already obtained the settings object
					// this.settings = extend(this.settings, this.overrides);
					_.extend(this.settings, this.overrides);
				}
			} catch (ex) {
				console.error('There was an error reading ' + filename + ': ', ex);
			}
			return this;
		}

		/**
   * ?? Reads the default profile
   */

	}, {
		key: 'whichProfile',
		value: function whichProfile() {
			this.profile = 'particle';
			this.readProfileData();
		}

		/**
   * in another file in our user dir, we store a profile name that switches between setting override files
   * @param {string} profileName  The name of the profile to switch to
   */

	}, {
		key: 'switchProfile',
		value: function switchProfile(profileName) {
			this.profile_json.name = profileName;
			this.saveProfileData();
		}

		/**
   * Reads "profile.json" and saves its content to profile_json
   * @return {undefined} nothing but keep the linter happy
   */

	}, {
		key: 'readProfileData',
		value: function readProfileData() {
			var fs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : require('fs');

			var particleDir = this.ensureFolder();
			var proFile = path.join(particleDir, 'profile.json'); //proFile, get it?
			if (fs.existsSync(proFile)) {
				try {
					var data = JSON.parse(fs.readFileSync(proFile));
					this.profile = data ? data.name : 'particle';
					this.profile_json = data;
				} catch (err) {
					throw new Error('Error parsing file ' + proFile + ': ' + err);
				}
			} else {
				this.profile = 'particle';
				this.profile_json = {};
			}
		}

		/**
   * Saves profile.json
   */

	}, {
		key: 'saveProfileData',
		value: function saveProfileData() {
			var fs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : require('fs');

			var particleDir = this.ensureFolder();
			var proFile = path.join(particleDir, 'profile.json'); //proFile, get it?
			fs.writeFileSync(proFile, JSON.stringify(this.profile_json, null, 2), { mode: '600' });
		}

		// this is here instead of utilities to prevent a require-loop
		// when files that utilties requires need settings

	}, {
		key: 'matchKey',
		value: function matchKey(needle, obj, caseInsensitive) {
			needle = caseInsensitive ? needle.toLowerCase() : needle;
			for (var key in obj) {
				var keyCopy = caseInsensitive ? key.toLowerCase() : key;
				if (keyCopy === needle) {
					return key; //return the original
				}
			}
			return null;
		}
	}, {
		key: 'override',
		value: function override(profile, key, value) {
			if (!this.overrides) {
				this.overrides = {};
			}

			if (this.settings[key] === undefined) {
				// find any key that matches our key, regardless of case
				var realKey = this.matchKey(key, this.settings, true);
				if (realKey) {
					//console.log("Using the setting \"" + realKey + "\" instead ");
					key = realKey;
				}
			}

			if (value === undefined) {
				delete this.settings[key];
				delete this.overrides[key];
			} else {
				//store the new value (redundant)
				this.settings[key] = value;

				//store that in overrides
				this.overrides[key] = value;
			}
			//make sure our overrides are in sync
			_.extend(this.settings, this.overrides);

			var filename = this.findOverridesFile(profile);
			try {
				fs.writeFileSync(filename, JSON.stringify(this.overrides, null, 2), { mode: '600' });
			} catch (ex) {
				console.error('There was an error writing ' + filename + ': ', ex);
			}
		}
	}, {
		key: 'transitionSparkProfiles',
		value: function transitionSparkProfiles() {
			var fs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : require('fs');
			var notifyTranslate = arguments[1];

			var sparkDir = path.join(this.findHomePath(), '.spark');
			var particleDir = path.join(this.findHomePath(), '.particle');
			if (fs.existsSync(sparkDir) && !fs.existsSync(particleDir)) {
				fs.mkdirSync(particleDir);

				if (notifyTranslate) {
					notifyTranslate(sparkDir, particleDir);
				}

				var files = fs.readdirSync(sparkDir);
				files.forEach(function (filename) {
					var data = fs.readFileSync(path.join(sparkDir, filename));
					var jsonData = void 0;
					try {
						jsonData = JSON.parse(data);
					} catch (ex) {
						// invalid JSON, don't transition
						return;
					}

					if (filename === 'profile.json') {
						if (jsonData.name === 'spark') {
							jsonData.name = 'particle';
						}
					}

					if (filename === 'spark.config.json') {
						filename = 'particle.config.json';
					}

					if (jsonData.apiUrl && jsonData.apiUrl.indexOf('.spark.io') > 0) {
						jsonData.apiUrl = jsonData.apiUrl.replace('.spark.io', '.particle.io');
					}

					var jsonString = JSON.stringify(jsonData, null, 2);
					fs.writeFileSync(path.join(particleDir, filename), jsonString, { mode: '600' });
				});
			}
		}
	}, {
		key: 'listConfigs',
		value: function listConfigs() {
			var particleDir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.ensureFolder();

			var files = utilities.globList(null, [path.join(particleDir, '*.config.json')]);

			return files.map(function (item) {
				var filename = path.basename(item);
				//strip the extension
				var name = filename.replace('.config.json', '');
				return name;
			});
		}

		/**
   * Retrieves a function that can retrieve or set a value.
   * @param {string} key       The key of the setting to fetch/update
   * @returns {function(newValue)}   A function that fetches the current value, or updates if an argument
   * is defined.
   */

	}, {
		key: 'fetchUpdate',
		value: function fetchUpdate(key) {
			function fetchUpdateKey(key, value) {
				if (value !== undefined) {
					this.set(key, value);
					return value;
				} else {
					return this.get(key);
				}
			}
			return fetchUpdateKey.bind(this, key);
		}
	}]);

	return Settings;
}();

var defaultSettings = {
	apiUrl: 'https://api.particle.io',
	buildUrl: 'https://build.particle.io',
	access_token: null,

	notSourceExtensions: ['.ds_store', '.jpg', '.gif', '.png', '.include', '.ignore', '.ds_store', '.git', '.bin'],

	dirIncludeFilename: 'particle.include',
	dirExcludeFilename: 'particle.ignore',

	knownApps: {
		'deep_update_2014_06': true,
		'cc3000': true,
		'cc3000_1_14': true,
		'tinker': true,
		'voodoo': true
	},
	knownPlatforms: {
		0: 'Core',
		6: 'Photon',
		8: 'P1',
		10: 'Electron',
		88: 'Duo',
		103: 'Bluz'
	},
	updates: {
		'2b04:d006': {
			systemFirmwareOne: 'system-part1-0.6.1-photon.bin',
			systemFirmwareTwo: 'system-part2-0.6.1-photon.bin'
		},
		'2b04:d008': {
			systemFirmwareOne: 'system-part1-0.6.1-p1.bin',
			systemFirmwareTwo: 'system-part2-0.6.1-p1.bin'
		},
		'2b04:d00a': {
			// The bin files MUST be in this order to be flashed to the correct memory locations
			systemFirmwareOne: 'system-part2-0.6.1-electron.bin',
			systemFirmwareTwo: 'system-part3-0.6.1-electron.bin',
			systemFirmwareThree: 'system-part1-0.6.1-electron.bin'
		}
	}
};

function buildSettings(separateSettings, initialSettings, skipLoadProfile) {
	var settings = new Settings({ separateSettings: separateSettings, settings: [defaultSettings, initialSettings] });
	if (!skipLoadProfile) {
		settings.transitionSparkProfiles();
		settings.whichProfile();
		settings.loadOverrides();
	}
	return settings;
}

exports.buildSettings = buildSettings;
exports.defaultSettings = defaultSettings;
exports.Settings = Settings;