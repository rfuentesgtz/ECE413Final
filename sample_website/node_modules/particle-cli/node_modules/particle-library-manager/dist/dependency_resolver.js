"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//const semver = require('semver');

var Dependency = exports.Dependency = function Dependency(name, version) {
	_classCallCheck(this, Dependency);

	this.name = name;
	this.version = version;
};

/**
 * Maintains state between invocations against a dependency resolver.
 */


var DependencyResolverSession = exports.DependencyResolverSession = function () {
	function DependencyResolverSession() {
		_classCallCheck(this, DependencyResolverSession);
	}

	_createClass(DependencyResolverSession, [{
		key: "constrctor",
		value: function constrctor(libraryRepo) {
			this.repo = libraryRepo;
		}
	}, {
		key: "dependencies",
		value: function dependencies(dependency) {}
	}]);

	return DependencyResolverSession;
}();

/**
 * Encapsulates the logic required to resolve dependencies.
 */


var DependencyResolver = exports.DependencyResolver = function () {
	function DependencyResolver() {
		_classCallCheck(this, DependencyResolver);
	}

	_createClass(DependencyResolver, [{
		key: "collectDependencies",


		/**
   * Determines the transitive closure of dependencies from a given set of roots.
   * @param {object} session   The dependency resolution session
   * @param {Array<object>} roots     The dependency roots.
   * @returns {object} something to please the linter
   */
		value: function collectDependencies(session, roots) {
			// iterate across the list of roots
			// for each root, fetch the subdependencies and add any that don't already
			// exist in the list to the end of the list.

			// after this, the list may contain multiple versions for a given library

		}
	}, {
		key: "resolveDependencies",
		value: function resolveDependencies(session, dependencies) {
			// the dependencies are bucketed by library and version
			// then each version reduced to a single item (the most recent)

			// this provides the final list of dependencies for the given set of roots
		}
	}]);

	return DependencyResolver;
}();