'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LibraryContributor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _validation = require('./validation');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _tarFs = require('tar-fs');

var _tarFs2 = _interopRequireDefault(_tarFs);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _tmp = require('tmp');

var _tmp2 = _interopRequireDefault(_tmp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var minimatch = require('minimatch');

var defaultWhitelist = ['*.ino', '*.pde', '*.cpp', '*.c', '*.c++', '*.h', '*.h++', '*.hpp', '*.ipp', '*.properties', '*.md', '*.txt', '*.S', '*.a', 'LICENSE'];

/**
 * Creates the tar.gz stream for sending to the library api to contribute the library.
 */

var LibraryContributor = exports.LibraryContributor = function (_EventEmitter) {
	_inherits(LibraryContributor, _EventEmitter);

	/**
  * @param {FileSystemLibraryRepository} repo  The repo containing the library.
  * @param {Particle.Client} client  The particle-api.js client.
  */
	function LibraryContributor(_ref) {
		var repo = _ref.repo,
		    client = _ref.client;

		_classCallCheck(this, LibraryContributor);

		var _this = _possibleConstructorReturn(this, (LibraryContributor.__proto__ || Object.getPrototypeOf(LibraryContributor)).call(this));

		Object.assign(_this, { repo: repo, client: client });
		return _this;
	}

	_createClass(LibraryContributor, [{
		key: '_isdirectory',
		value: function _isdirectory(name) {
			try {
				return _fs2.default.statSync(name).isDirectory();
			} catch (error) {
				return false;
			}
		}

		/**
   * @param {string} dir  The directory the filter will be operating on.
   * @param {Array.<string>} whitelist Array of glob patterns to whitelist.
   * @return {function} a function that takes a filename as string and returns
   * true if the file should be excluded from the library archive.
   */

	}, {
		key: '_buildFilter',
		value: function _buildFilter(dir, whitelist) {
			var _this2 = this;

			var expr = this._buildMatchExpression(whitelist);
			// match the file base (ignore the directory)
			// allow dots as a prefix (allows .gitignore)
			// case-insensitive match
			var matcher = minimatch.filter(expr, { matchBase: true, dot: true, nocase: true });
			return function (name) {
				var originalName = name;
				var isdir = _this2._isdirectory(name);
				name = _path2.default.relative(dir, name); // ensure it's relative
				if (isdir) {
					// designate as a directory
					name = name + _path2.default.sep;
				}
				var dirname = _path2.default.dirname(name);
				var dirs = dirname.split(_path2.default.sep);
				var isgit = dirs.length && dirs[0] === '.git';
				var result = void 0;
				if (isgit) {
					result = true;
				} else if (isdir) {
					result = false; // // do not ignore - always allow directories. The glob is only applied to files
				} else {
					result = !matcher(name);
				}
				_this2.emit('file', originalName, result);
				return result;
			};
		}

		/**
   * @param {Array.<string>} globs An array of glob expressions.
   * @returns {string} The glob match expression
   * @private
   */

	}, {
		key: '_buildMatchExpression',
		value: function _buildMatchExpression(globs) {
			globs = globs.map(function (item) {
				return item.trim();
			});
			return '+(' + globs.join('|') + ')';
		}

		/**
   * Creates a tar.gz stream containing the contents of the given directory in the file system that can be piped to another stream.
   * @param {string} dir The directory to tar.gz
   * @param {Array.<string>} whitelist The files to include in the library.
   * @returns {ReadableStream} a stream that can be piped to a writableStream to provide the tar.gz file.
   */

	}, {
		key: '_targzdir',
		value: function _targzdir(dir, whitelist) {
			var _this3 = this;

			return new Promise(function (fulfill, reject) {
				// WORKAROUND: form-data in superagent in particle-api-js only supports file streams so copy to a temporary file
				var archive = _tmp2.default.fileSync();

				var archiveWriter = _fs2.default.createWriteStream(archive.name);
				var gzip = _zlib2.default.createGzip();

				var pack = _tarFs2.default.pack(dir, {
					ignore: _this3._buildFilter(dir, whitelist),
					readable: true
				});
				pack.pipe(gzip).pipe(archiveWriter);

				archiveWriter.on('finish', function () {
					var archiveReader = _fs2.default.createReadStream(archive.name);
					fulfill(archiveReader);
				});

				archiveWriter.on('error', reject);
			});
		}
	}, {
		key: '_contribute',
		value: function _contribute(name, stream) {
			return this.client.contributeLibrary(stream);
		}
	}, {
		key: '_validateLibrary',
		value: function _validateLibrary(repo, name) {
			return (0, _validation.validateLibrary)(repo, name);
		}

		/**
   * Contributes a library with the given name from the repo.
   * @param {function} callback  Called during the contributing process:
   *  callback('validatingLibrary', name)
   *  callback('contributingLibrary', library)
   *  callback('contributeComplete', library)
   *
   * @param {string} name The name of the library to contribute.
   * @param {boolean} dryRun When true, the library is only validated, and not contributeed.
   * @return {Promise} to contribute the named library.
   */

	}, {
		key: 'contribute',
		value: function contribute(callback, name) {
			var dryRun = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

			var libraryDirectory = this.repo.libraryDirectory(name);
			return this._doContribute(callback, name, libraryDirectory, dryRun);
		}
	}, {
		key: '_doContribute',
		value: function _doContribute(callback, name, libraryDirectory, dryRun) {
			var _this4 = this;

			var validatePromise = this._buildValidatePromise(name);
			// mdm - not sure about allowing the site to wrap the promise since it can potentially cause parts of the command
			// code to not execute if the returned promise doesn't chain the validatePromise.
			return this._buildNotifyPromise(callback, 'validatingLibrary', validatePromise, libraryDirectory).then(function () {
				return _this4._doContributeDirect(callback, name, libraryDirectory, dryRun);
			});
		}
	}, {
		key: '_doContributeDirect',
		value: function _doContributeDirect(callback, name, libraryDirectory, dryRun) {
			var _this5 = this;

			return this.repo.fetch(name).then(function (library) {
				return _this5._doContributeLibrary(callback, library, libraryDirectory, dryRun);
			});
		}
	}, {
		key: '_buildWhitelist',
		value: function _buildWhitelist(defaultWhitelist, whitelist) {
			return defaultWhitelist.concat(whitelist);
		}

		/**
   * Parses a whitelist string, which is a comma-separated list of glob expressions
   * @param {string} whitelist    The string to parse
   * @returns {Array.<string>}    The list of array globs.
   * @private
   */

	}, {
		key: '_parseWhitelist',
		value: function _parseWhitelist(whitelist) {
			return whitelist ? whitelist.split(',') : [];
		}
	}, {
		key: '_doContributeLibrary',
		value: function _doContributeLibrary(callback, library, libraryDirectory, dryRun) {
			var whitelist = this._buildWhitelist(defaultWhitelist, this._parseWhitelist(library.whitelist));
			var contributePromise = this._buildContributePromise(libraryDirectory, library.name, whitelist, dryRun);
			var notify = this._buildNotifyPromise(callback, 'contributingLibrary', contributePromise, library);
			return notify.then(function () {
				return callback('contributeComplete', library);
			});
		}

		/**
   * Notifies the callback function with the given notification and promise and optinoal arguments.
   * The callback may chain the promise or return a false value.
   * @param {function} callback      The callback to call
   * @param {string} notify        The notification event
   * @param {Promise} promise       The promise that will be executed
   * @param {Array} other         Additional arguments
   * @returns {*|Promise.<*>} The promise that will notify the callback and run the promise.
   * @private
   */

	}, {
		key: '_buildNotifyPromise',
		value: function _buildNotifyPromise(callback, notify, promise) {
			for (var _len = arguments.length, other = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
				other[_key - 3] = arguments[_key];
			}

			return Promise.resolve().then(function () {
				return callback.apply(undefined, [notify, promise].concat(other));
			}).then(function (wrapped) {
				return wrapped || promise;
			});
		}
	}, {
		key: '_buildValidatePromise',
		value: function _buildValidatePromise(name) {
			return this._validateLibrary(this.repo, name).then(function (results) {
				if (results && !results.valid) {
					var error = new Error('Library is not valid. ' + (0, _validation.validationMessage)(results));
					error.validate = results;
					throw error;
				}
			});
		}

		/**
   * Constructs a promise to perform the contributing of the library.
   * @param {string} libraryDirectory      The directory of the library to contribute.
   * @param {string} libraryName           The name of the library in the repo
   * @param {string} libraryWhitelist      The array of globs to whitelist
   * @param {boolean} dryRun               When true, the library is only zipped, and not contributeed.
   * @returns {*|Promise.<boolean>}       Promise to contribute the library.
   * @private
   */

	}, {
		key: '_buildContributePromise',
		value: function _buildContributePromise(libraryDirectory, libraryName, libraryWhitelist, dryRun) {
			var _this6 = this;

			return Promise.resolve(this._targzdir(libraryDirectory, libraryWhitelist)).then(function (pipe) {
				return dryRun ? true : _this6._contribute(libraryName, pipe);
			});
		}
	}]);

	return LibraryContributor;
}(_events2.default);