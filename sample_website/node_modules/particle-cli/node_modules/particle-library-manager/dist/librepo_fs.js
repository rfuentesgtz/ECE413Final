'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.FileSystemLibraryRepository = exports.FileSystemNamingStrategy = exports.sparkDotJson = exports.FileSystemLibraryFile = exports.NamingStrategy = exports.FileSystemLibrary = exports.libraryProperties = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.mapActionDir = mapActionDir;
exports.getdirs = getdirs;
exports.pathsCommonPrefix = pathsCommonPrefix;
exports.isLibraryExample = isLibraryExample;

var _librepo = require('./librepo');

var _verror = require('verror');

var _verror2 = _interopRequireDefault(_verror);

var _libcontribute = require('./libcontribute');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ******************************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Copyright (c) 2016 Particle Industries, Inc.  All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                This program is free software; you can redistribute it and/or
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                modify it under the terms of the GNU Lesser General Public
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                License as published by the Free Software Foundation, either
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                version 3 of the License, or (at your option) any later version.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                This program is distributed in the hope that it will be useful,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                but WITHOUT ANY WARRANTY; without even the implied warranty of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Lesser General Public License for more details.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                You should have received a copy of the GNU Lesser General Public
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                License along with this program; if not, see <http://www.gnu.org/licenses/>.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ******************************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var fs = require('fs');
var path = require('path');
var promisify = require('es6-promisify');
var properties = require('properties-parser');

/**
 *
 * @param {string} rootDir               The directory to scan, map and action.
 * @param {function} mapper       Called with (stat,file,filePath) for each item in the directory.
 * @param {function} action         Called with actionables from the mapper function.
 * @returns {Promise} promise that returns an array of items returned from invoking the mapper and action for each
 *  item in the directory.
 */
function mapActionDir(rootDir, mapper, action) {
	var stat = promisify(fs.stat);
	var readdir = promisify(fs.readdir);
	return readdir(rootDir).then(function (files) {
		var filePromises = files.map(function (file) {
			var filePath = path.join(rootDir, file);
			return stat(filePath).then(function (stat) {
				return mapper(stat, file, filePath);
			});
		});
		return Promise.all(filePromises).then(function (actionables) {
			return action(actionables, files);
		});
	});
}

function isDirectory(stat) {
	return stat.isDirectory();
}

/**
 * Filters a given array and removes all with a non-truthy vale in the corresponding predicate index.
 * @param {Array} predicates        The predicates for each item to filter.
 * @param {Array} items             The items to filter.
 * @returns {Array<T>} The itmes array with all those that didn't satisfy the predicate removed.
 */
function removeFailedPredicate(predicates, items) {
	return items.filter(function (_, i) {
		return predicates[i] === true;
	});
}

/**
 * Promises to retrieve the directories contained within a directory.
 * @param {string} rootDir      The directory to scan.
 * @returns {Promise<Array<string>>} The names of directories containing in rootDir.
 */
function getdirs(rootDir) {
	return mapActionDir(rootDir, isDirectory, removeFailedPredicate);
}

var libraryProperties = exports.libraryProperties = 'library.properties';

var FileSystemLibrary = exports.FileSystemLibrary = function (_AbstractLibrary) {
	_inherits(FileSystemLibrary, _AbstractLibrary);

	/**
  *
  * @param {string} name The name this library is identified by in the filesystem.
  * @param {object} metadata The library descriptor.
  * @param {FileSystemLibraryRepo} repo The repository this library is managed by.
  */
	function FileSystemLibrary(name, metadata, repo) {
		_classCallCheck(this, FileSystemLibrary);

		return _possibleConstructorReturn(this, (FileSystemLibrary.__proto__ || Object.getPrototypeOf(FileSystemLibrary)).call(this, name, metadata, repo));
	}

	return FileSystemLibrary;
}(_librepo.AbstractLibrary);

var NamingStrategy = exports.NamingStrategy = function () {
	function NamingStrategy() {
		_classCallCheck(this, NamingStrategy);
	}

	_createClass(NamingStrategy, [{
		key: 'toName',


		/**
   * Generates a filesystem-safe name for a library.
   * @param {object} metadata The library metadata to generate a name for.
   * @return {string} An identifier for this library, derived from the library metadata.
   * @abstract
   */
		value: function toName(metadata) {
			throw new Error('not implemented');
		}
	}, {
		key: 'nameToFilesystem',
		value: function nameToFilesystem(name) {
			return name;
		}

		/**
   * Fetches all the names for a given repo.
   * @param {FileSystemLibraryRepo} repo The repo to fetch the names for.
   * @returns {Promise.<Array<string>>} The logical names of libraries available in this repo.
   */

	}, {
		key: 'names',
		value: function names(repo) {
			var stat = promisify(fs.stat);
			return getdirs(repo.path).then(function (dirs) {
				var libPromises = dirs.map(function (dir) {
					var filePath = repo.descriptorFileV2(dir);
					// todo - map directory names back to the library name (if some encoding is used.)
					return stat(filePath).then(function (stat) {
						return stat.isFile();
					}).catch(function (error) {
						return false;
					});
				});

				return Promise.all(libPromises).then(function (isLib) {
					return dirs.filter(function (_, i) {
						return isLib[i];
					});
				});
			});
		}

		/**
   * Determines if the given name matches the name corresponding to the descriptor.
   * This allows the strategy to introduce name aliases.
   * @param {object} descriptor The library metadata to check.
   * @param {string} name The library identifier to check.
   * @returns {boolean} true if the name matches the descriptor.
   */

	}, {
		key: 'matchesName',
		value: function matchesName(descriptor, name) {
			return this.toName(descriptor) === name;
		}
	}]);

	return NamingStrategy;
}();

var LibraryNameStrategy = function (_NamingStrategy) {
	_inherits(LibraryNameStrategy, _NamingStrategy);

	function LibraryNameStrategy() {
		_classCallCheck(this, LibraryNameStrategy);

		return _possibleConstructorReturn(this, (LibraryNameStrategy.__proto__ || Object.getPrototypeOf(LibraryNameStrategy)).apply(this, arguments));
	}

	_createClass(LibraryNameStrategy, [{
		key: 'toName',
		value: function toName(library) {
			return library.name;
		}
	}]);

	return LibraryNameStrategy;
}(NamingStrategy);

var LibraryNameAtVersionStrategy = function (_NamingStrategy2) {
	_inherits(LibraryNameAtVersionStrategy, _NamingStrategy2);

	function LibraryNameAtVersionStrategy() {
		_classCallCheck(this, LibraryNameAtVersionStrategy);

		return _possibleConstructorReturn(this, (LibraryNameAtVersionStrategy.__proto__ || Object.getPrototypeOf(LibraryNameAtVersionStrategy)).apply(this, arguments));
	}

	_createClass(LibraryNameAtVersionStrategy, [{
		key: 'toName',
		value: function toName(library) {
			return library.name + '@' + library.version;
		}
	}]);

	return LibraryNameAtVersionStrategy;
}(NamingStrategy);

var LibraryDirectStrategy = function (_NamingStrategy3) {
	_inherits(LibraryDirectStrategy, _NamingStrategy3);

	function LibraryDirectStrategy() {
		_classCallCheck(this, LibraryDirectStrategy);

		return _possibleConstructorReturn(this, (LibraryDirectStrategy.__proto__ || Object.getPrototypeOf(LibraryDirectStrategy)).apply(this, arguments));
	}

	_createClass(LibraryDirectStrategy, [{
		key: 'toName',
		value: function toName(library) {
			return library.name;
		}

		/**
   * Library stored in the root of the repo, so all names map to ''.
   * @param {string} name The name of the library, as previously provided by `toName`.
   * @returns {string} The filesystem name of the corresponding logical library name.
   *
   */

	}, {
		key: 'nameToFilesystem',
		value: function nameToFilesystem(name) {
			return '';
		}
	}, {
		key: 'matchesName',
		value: function matchesName(descriptor, name) {
			return name === '' ? true : _get(LibraryDirectStrategy.prototype.__proto__ || Object.getPrototypeOf(LibraryDirectStrategy.prototype), 'matchesName', this).call(this, descriptor, name);
		}

		/**
   * @param {FileSystemLibraryRepo} repo The repo to use that provides the library descriptors.
   * @returns {Promise<Array<string>>} A list of the library names in the repo.
   */

	}, {
		key: 'names',
		value: function names(repo) {
			var _this5 = this;

			var filename = repo.descriptorFileV2('');
			return repo.fileStat(filename).then(function (stat) {
				if (stat && stat.isFile()) {
					return repo.readDescriptorV2('', filename).then(function (descriptor) {
						return [_this5.toName(descriptor)];
					});
				}
				return [];
			});
		}
	}]);

	return LibraryDirectStrategy;
}(NamingStrategy);

var FileSystemLibraryFile = exports.FileSystemLibraryFile = function (_LibraryFile) {
	_inherits(FileSystemLibraryFile, _LibraryFile);

	function FileSystemLibraryFile(fileName, name, kind, extension) {
		_classCallCheck(this, FileSystemLibraryFile);

		var _this6 = _possibleConstructorReturn(this, (FileSystemLibraryFile.__proto__ || Object.getPrototypeOf(FileSystemLibraryFile)).call(this, name, kind, extension));

		_this6.fileName = fileName;
		return _this6;
	}

	_createClass(FileSystemLibraryFile, [{
		key: 'content',
		value: function content(stream) {
			var source = fs.createReadStream(this.fileName);
			source.pipe(stream);
		}
	}]);

	return FileSystemLibraryFile;
}(_librepo.LibraryFile);

var sparkDotJson = exports.sparkDotJson = 'spark.json';
var firmwareDir = 'firmware';
var examplesDir = 'examples';
var testDir = 'test';
var unitDir = 'unit';
var srcDir = 'src';

var FileSystemNamingStrategy = exports.FileSystemNamingStrategy = {
	BY_NAME: new LibraryNameStrategy(),
	BY_NAME_AT_VERSION: new LibraryNameAtVersionStrategy(),
	DIRECT: new LibraryDirectStrategy()
};

/**
 * A library repository that retrieves and stores libraries in a file system directory.
 * The repo has a root directory, and uses a naming strategy is used to determine how libraries are
 * stored under that directory.
 */

var FileSystemLibraryRepository = exports.FileSystemLibraryRepository = function (_AbstractLibraryRepos) {
	_inherits(FileSystemLibraryRepository, _AbstractLibraryRepos);

	/**
  * Creates a new FileSystemLibraryRepository instance.
  * @param {string} repoPath The location of the file system repository. The contained
  * libraries are stored as subdirectories under the repo root.
  * @param {NamingStrategy} namingStrategy The strategy that maps library metadata to an identifying name,
  * and maps that name to the filesystem.
  */
	function FileSystemLibraryRepository(repoPath, namingStrategy) {
		_classCallCheck(this, FileSystemLibraryRepository);

		var _this7 = _possibleConstructorReturn(this, (FileSystemLibraryRepository.__proto__ || Object.getPrototypeOf(FileSystemLibraryRepository)).call(this));

		if (!namingStrategy) {
			namingStrategy = FileSystemNamingStrategy.BY_NAME;
		}

		if (!repoPath.endsWith(path.sep)) {
			repoPath += path.sep;
		}
		_this7.path = repoPath;
		_this7.namingStrategy = namingStrategy;
		_this7.sourceExtensions = { 'c': true, 'cpp': true, 'h': true };
		return _this7;
	}

	/**
  * A nod to the fact we need to sanitize library names for the fs...
  * @param {string} name      The name to sanitize
  * @returns {string} a sanitized name.
  */


	_createClass(FileSystemLibraryRepository, [{
		key: 'nameToFs',
		value: function nameToFs(name) {
			return name;
		}
	}, {
		key: 'nameFor',
		value: function nameFor(library) {
			return this.namingStrategy.toName(library.metadata);
		}

		/**
   * Determines the location of a library file in the filesystem.
   * @param {string} libraryName the identifier for a library, as provided by the strategy.
   * @param {string} fileName the filename of a logical file in the library
   * @param {string} fileExt the extension of a logical file in the library
   * @returns {string} The location in the filesystem of the file corresponding to the
   * library file.
   */

	}, {
		key: 'libraryFileName',
		value: function libraryFileName(libraryName, fileName, fileExt) {
			return this.libraryDirectory(libraryName) + fileName + (fileExt ? '.' + fileExt : '');
		}

		/**
   * Copy a given file to this library.
   * @param {string} libraryName the target library name (according to the naming strategy.)
   * @param {LibraryFile} libraryFile   The library file to copy to the target library.
   * @return {Promise} to copy the library file.
   */

	}, {
		key: 'copyLibraryFile',
		value: function copyLibraryFile(libraryName, libraryFile) {
			var _this8 = this;

			return Promise.resolve().then(function () {
				var fileName = _this8.libraryFileName(libraryName, libraryFile.name, libraryFile.extension);
				var dir = path.dirname(fileName);
				_this8.createDirectory(dir);
				var outputStream = fs.createWriteStream(fileName);
				libraryFile.content(outputStream);
			});
		}
	}, {
		key: 'createDirectory',
		value: function createDirectory(dir) {
			if (!fs.existsSync(dir)) {
				var parent = path.normalize(path.join(dir, '..'));
				this.createDirectory(parent);
				fs.mkdirSync(dir);
			}
		}

		/**
   * Determines if a library file should be persisted. Only source files are persisted.
   * @param {LibraryFile} libraryFile The file to be checked.
   * @returns {boolean} true if the library should be persisted.
   */

	}, {
		key: 'includeLibraryFile',
		value: function includeLibraryFile(libraryFile) {
			return libraryFile.kind === 'source' || libraryFile.kind === 'header';
		}

		/**
   * Adds a library to this repo. The descriptor and source files are written out. Example files are presently
   * not included.
   * @param {Library} library The library to add.
   * @param {Number} layout   The layout version to use. 1 means legacy v1 (with firmware directory), 2 means library v2.
      * @return {Promise} promise to create the library.
   */

	}, {
		key: 'add',
		value: function add(library) {
			var _this9 = this;

			var layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

			var name = this.nameFor(library);
			if (this.namingStrategy.nameToFilesystem(name) === '') {
				return Promise.reject(new _librepo.LibraryRepositoryError(this, 'repo is not writable'));
			}

			var mkdir = promisify(fs.mkdir);
			return Promise.resolve().then(function () {
				return mkdir(_this9.libraryDirectory(name));
			}).then(function () {
				return library.definition();
			}).then(function (definition) {
				if (layout === 1) {
					return _this9.writeDescriptorV1(_this9.descriptorFileV1(name), definition);
				} else {
					return _this9.writeDescriptorV2(_this9.descriptorFileV2(name), definition);
				}
			}).then(function () {
				return library.files();
			}).then(function (files) {
				var copyFiles = [];
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					var _loop = function _loop() {
						var file = _step.value;

						if (_this9.includeLibraryFile(file)) {
							copyFiles.push(Promise.resolve().then(function () {
								return _this9.copyLibraryFile(name, file);
							}));
						}
					};

					for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						_loop();
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				return Promise.all(copyFiles);
			});
		}

		/**
   * Removes the id field from the metadata.
   * @param {object} metadata  The object to clone and remove the ID from.
   * @returns {object} The metadata with the id removed.
   */

	}, {
		key: 'removeId',
		value: function removeId(metadata) {
			var m = Object.assign({}, metadata);
			delete m.id;
			return m;
		}

		/**
   * Writes the library v1 descriptor to file.
   * @param {string} toFile The file to write to
   * @param {object} metadata The library metadata
   * @returns {*} Promise to write the descriptor to `toFile`.
   */

	}, {
		key: 'writeDescriptorV1',
		value: function writeDescriptorV1(toFile, metadata) {
			var writeFile = promisify(fs.writeFile);
			var m = this.removeId(metadata);
			var content = JSON.stringify(m);
			return writeFile(toFile, content);
		}
	}, {
		key: 'buildV2Descriptor',
		value: function buildV2Descriptor(metadata, withComments) {
			var content = [];
			function addProperty(target, value, name, comment) {
				if (value !== undefined) {
					content.push(name + '=' + value + '\n');
				} else if (withComments) {
					content.push('# ' + name + '=' + comment + '\n');
				}
			}

			addProperty(content, metadata.name, 'name', 'the name of this library');
			addProperty(content, metadata.version, 'version', 'the current version of this library');
			addProperty(content, metadata.license, 'license', 'insert your choice of license here');
			addProperty(content, metadata.author, 'author', 'library author, e.g. name + email address');
			addProperty(content, metadata.description, 'sentence', 'one sentence description of this library');
			addProperty(content, metadata.paragraph, 'paragraph', 'a longer description of this library, always prepended with sentence when shown');
			addProperty(content, metadata.url, 'url', 'the url for the project');
			addProperty(content, metadata.repository, 'repository', 'git repository for the project, like https://github.com/mygithub_user/my_repo.git');
			addProperty(content, metadata.architectures && metadata.architectures.join(','), 'architectures', 'a list of supported boards if this library is hardware dependent, like particle-photon,particle-electron');
			return content.join('');
		}
	}, {
		key: 'writeDescriptorV2',
		value: function writeDescriptorV2(toFile, metadata, withComments) {
			var writeFile = promisify(fs.writeFile);
			this.prepareDescriptorV2(metadata);
			var content = this.buildV2Descriptor(metadata, withComments);
			return writeFile(toFile, content);
		}
	}, {
		key: 'prepareDescriptorV2',
		value: function prepareDescriptorV2(metadata) {
			if (!metadata.sentence && metadata.description) {
				metadata.sentence = metadata.description;
			}
			return metadata;
		}

		/**
   * Fetches a library from the repo.
   * @param {string} libraryIdentifier The filesystem identifier of the library to fetch,
   * typically derived from one of the values returned by `names()`.
   * @return {FileSystemLibrary} the library found.
   *
   * With the DIRECT strategy, a name of `` can be used to refer to the library at the
   * filesystem root.
   */

	}, {
		key: 'fetch',
		value: function fetch(libraryIdentifier) {
			var _this10 = this;

			// determine the real name used in the filesystem for a given library ID
			// (e.g. this allows the DIRECT strategy to map all names to '', since it supports
			// only one library in the root.)
			var name = this.namingStrategy.nameToFilesystem(libraryIdentifier);
			var filePath = this.descriptorFileV2(name);
			return this.readDescriptorV2(libraryIdentifier, filePath).then(function (descriptor) {
				// get the real name (the libraryIdentifier could be an alias.)
				libraryIdentifier = _this10.namingStrategy.toName(descriptor);
				return descriptor;
			}).then(function (descriptor) {
				return _this10._createLibrary(libraryIdentifier, descriptor);
			}).catch(function (error) {
				throw new _librepo.LibraryNotFoundError(_this10, name, error);
			});
		}
	}, {
		key: 'readDescriptorV2',
		value: function readDescriptorV2(name, repoPath) {
			var _this11 = this;

			var parse = promisify(properties.read);
			return parse(repoPath).then(function (props) {
				if (!_this11.namingStrategy.matchesName(props, name)) {
					throw new _librepo.LibraryFormatError(_this11, name, 'name in descriptor does not match directory name');
				}
				if (props.sentence !== undefined) {
					props.description = props.sentence;
				}
				if (props.architectures) {
					props.architectures = props.architectures.split(',');
				}
				return props;
			});
		}

		/**
   * Determines the location of a named directory within the filesystem space owned
   * by this repo.
   * @param {string} name a valid filename, not including a final path separator.
   * @returns {string} The full path of the directory.
   */

	}, {
		key: 'directory',
		value: function directory(name) {
			return name ? this.path + name + path.sep : this.path;
		}

		/**
   * Determines the directory where a library using the given name (from the naming strategy) is located.
   * @param {string} name The identifier of the library in the filesystem.
   * @return {string} The directory in the filesystem corresponding to the library identifier.
   */

	}, {
		key: 'libraryDirectory',
		value: function libraryDirectory(name) {
			return this.directory(this.namingStrategy.nameToFilesystem(name));
		}

		/**
   * Determine the file that contains the library descriptor.
   * @param {string} name The library name
   * @returns {string}    The file path of the library descriptor for the named library.
   */

	}, {
		key: 'descriptorFileV1',
		value: function descriptorFileV1(name) {
			return this.libraryDirectory(name) + sparkDotJson;
		}
	}, {
		key: 'descriptorFileV2',
		value: function descriptorFileV2(name) {
			return this.libraryDirectory(name) + libraryProperties;
		}
	}, {
		key: 'readDescriptorV1',
		value: function readDescriptorV1(name, filename) {
			return this.readFileJSON(name, filename);
		}

		/**
   * Reads a file and decodes the JSON
   * @param {string} name The library name. Used in error reporting.
   * @param {string} filename The file to decode.
   * @returns {Promise.<Object>} The promise to retrieve the library with the given name.
   */

	}, {
		key: 'readFileJSON',
		value: function readFileJSON(name, filename) {
			var _this12 = this;

			var readFile = promisify(fs.readFile);
			return readFile(filename, 'utf8').then(function (json) {
				return _this12._parseJSON(json);
			}).catch(function (error) {
				throw new _librepo.LibraryFormatError(_this12, name, new _verror2.default(error, 'error parsing "%s"', filename));
			});
		}
	}, {
		key: '_parseJSON',
		value: function _parseJSON(json) {
			return JSON.parse(json);
		}
	}, {
		key: '_createLibrary',
		value: function _createLibrary(name, metadata) {
			return new FileSystemLibrary(name, metadata, this);
		}

		/**
   * Finds the directories under the given path for this repo that contain a
   * `library.properties` file.
   * @returns {Promise.<Array.<String>>} The names of libraries in this repo.
   */

	}, {
		key: 'names',
		value: function names() {
			var result = this.namingStrategy.names(this);
			return result;
		}

		/**
   * Retrieves the definition object for a given library.
   * @param {FileSystemLibrary} lib   The library whose descriptor is fetched.
   * @returns {Promise.<object>} The promised library descriptor.
   */

	}, {
		key: 'definition',
		value: function definition(lib) {
			// the descriptor is fetched eagerly on construction
			return Promise.resolve(lib.metadata);
		}

		/**
   * Splits the file into its extension and the basename. The extension is given without the leading dot.
   * @param {string} name  the filename to split
   * @returns {[ext,basename]}    The extension and the baename
   */

	}, {
		key: 'extension',
		value: function extension(name) {
			var idx = name.lastIndexOf('.');
			return idx >= 0 ? [name.substring(idx + 1), name.substring(0, idx)] : ['', name];
		}
	}, {
		key: 'isSourceFile',
		value: function isSourceFile(stat, name) {
			return stat.isFile() && this.isSourceFileName(name);
		}
	}, {
		key: 'isSourceFileName',
		value: function isSourceFileName(name) {
			//return this.sourceExtensions[this.extension(name)[0]]!==false;
			return name !== libraryProperties;
		}

		/**
   * Retrieves the files for a library from the file system.
   * @param {Library} lib the library whose files should be retrieved.
   * @return {Promise<Array<LibraryFile>>} the files for this library
   */

	}, {
		key: 'files',
		value: function files(lib) {
			var _this13 = this;

			var libraryDir = this.libraryDirectory(this.nameFor(lib));
			// iterate over all the files and

			return mapActionDir(libraryDir, function () {
				return _this13.isSourceFile.apply(_this13, arguments);
			}, function (include, files) {
				var filtered = removeFailedPredicate(include, files);
				return _this13.createLibraryFiles(lib, filtered);
			});
		}
	}, {
		key: 'createLibraryFiles',
		value: function createLibraryFiles(lib, fileNames) {
			var _this14 = this;

			var libraryDir = this.libraryDirectory(this.nameFor(lib));
			var fileBuilders = fileNames.map(function (fileName) {
				return _this14.createLibraryFile(libraryDir, fileName);
			});
			return Promise.all(fileBuilders);
		}
	}, {
		key: 'createLibraryFile',
		value: function createLibraryFile(libraryDir, fileName) {
			var _extension = this.extension(fileName),
			    _extension2 = _slicedToArray(_extension, 2),
			    extension = _extension2[0],
			    baseFile = _extension2[1];

			return Promise.resolve(new FileSystemLibraryFile(libraryDir + fileName, baseFile, 'source', extension));
		}

		/**
   * Determines the layout of the library on disk.
   * @param {string} name  The name of the library to check.
   * @return {Number} 1 for layout version 1 (legacy) or 2 for layout version 2.
   */

	}, {
		key: 'getLibraryLayout',
		value: function getLibraryLayout(name) {
			var _this15 = this;

			var dir = this.libraryDirectory(this.namingStrategy.nameToFilesystem(name));
			var stat = promisify(fs.stat);
			var notFound = function notFound(error) {
				return error !== undefined ? new _librepo.LibraryNotFoundError(_this15, name, error) : new _librepo.LibraryNotFoundError(_this15, name);
			};
			return Promise.resolve().then(function () {
				return stat(dir).then(function (stat) {
					return stat.isDirectory();
				}).catch(function (err) {
					throw notFound(err);
				});
			}).then(function (exists) {
				if (exists) {
					return stat(path.join(dir, sparkDotJson)).then(function (stat) {
						if (stat.isFile()) {
							return 1;
						}
						throw notFound();
					}).catch(function () {
						return stat(path.join(dir, libraryProperties)).catch(function (err) {
							throw notFound(err);
						}).then(function (stat) {
							if (stat.isFile()) {
								return 2;
							}
							throw notFound();
						});
					});
				}
				throw notFound();
			});
		}
	}, {
		key: 'mkdirIfNeeded',
		value: function mkdirIfNeeded(dir) {
			return promisify(fs.mkdir)(dir).catch(function (err) {
				// I tried using stat to check if the directory exists, but we then
				// end up with many checks queued first, followed by many calls to
				// mkdir, which would then fail. This is the most reliable way, if a bit smelly.
				if (err.code !== 'EEXIST') {
					throw err; // ignore that it exists, throw other errors.
				}
			});
		}
	}, {
		key: 'fileStat',
		value: function fileStat(filename) {
			return promisify(fs.stat)(filename).catch(function () {
				return null;
			});
		}
	}, {
		key: 'setLibraryLayout',
		value: function setLibraryLayout(name, layout) {
			var _this16 = this;

			return this.getLibraryLayout(name).then(function (currentLayout) {
				if (currentLayout !== layout) {
					// some change needed
					if (layout !== 2 || currentLayout !== 1) {
						// support only migrate to v2 for now
						throw new _librepo.LibraryRepositoryError(_this16, 'the requested library migration is not supported');
					}
					return _this16.migrateV2(name);
				}
			});
		}

		/**
   * @param {string} orgName      The name of the library to migrate.
   * @returns {Promise.<*>}    Promise to migrate the library.
   * @private
  	 migrate to a v2 structure
   - read spark.json and serialize as library.properties
   - change description to sentence property
   - for each .cpp/.ino file in firmware/examples/, create a directory named after the base filename
   and store the file in there, passing the file through the include fixup filter
   - if it exists, change the path of firmware/test/* to test/unit/*
   - change the path of firmware/* to src/*  (i.e. mv firmware src), and for each file fix up the include paths.
  	 The copy operation is done in an idempotent manner, copying files to their new locations and then
   destroying the old files.
  	 When migration is complete:
   - delete firmware recursively
   - delete spark.json
  	 */

	}, {
		key: 'migrateV2',
		value: function migrateV2(orgName) {
			var _this17 = this;

			var fse = require('fs-extra');
			var name = this.namingStrategy.nameToFilesystem(orgName);
			var libdir = this.libraryDirectory(name);
			var v1descriptorFile = this.descriptorFileV1(name, libdir);
			var v2descriptorFile = this.descriptorFileV2(name, libdir);

			var v1test = path.join(libdir, firmwareDir, testDir);
			var v2test = path.join(libdir, testDir, unitDir);
			var includeName = void 0;

			return this.readDescriptorV1(orgName, v1descriptorFile).then(function (v1desc) {
				includeName = v1desc.name;
				var v2desc = _this17.migrateDescriptor(v1desc);
				return _this17.writeDescriptorV2(v2descriptorFile, v2desc, true);
			}).then(function () {
				return _this17.fileStat(v1test).then(function (stat) {
					if (stat) {
						return _this17.mkdirIfNeeded(path.join(libdir, testDir)).then(function () {
							return promisify(fs.rename)(v1test, v2test);
						});
					}
				});
			}).then(function () {
				return _this17.migrateSources(libdir, includeName);
			}).then(function () {
				return _this17.migrateExamples(libdir, includeName);
			}).then(function () {
				return promisify(fse.remove)(path.join(libdir, firmwareDir));
			}).then(function () {
				return promisify(fse.remove)(v1descriptorFile);
			});
		}
	}, {
		key: 'migrateSources',
		value: function migrateSources(libdir, name) {
			var v1 = path.join(libdir, firmwareDir);
			var v2 = path.join(libdir, srcDir);
			var self = this;
			function mapper(stat, source, filePath) {
				if (stat.isFile()) {
					return self.migrateSource(name, source, v1, v2);
				}
			}
			return mapActionDir(v1, mapper, function (promises) {
				return promises.filter(function (item) {
					return item;
				});
			});
		}

		/**
   * Migrates a single source file from v1 to v2.
   * @param {string} lib the name of the library being migrated
   * @param {string} source the name of the source file
   * @param {string} v1dir the v1 library sources directory
   * @param {string} v2dir the v2 library sources directory
   * @returns {Promise} to migrate the source file
   */

	}, {
		key: 'migrateSource',
		value: function migrateSource(lib, source, v1dir, v2dir) {
			var _this18 = this;

			return this.mkdirIfNeeded(v2dir).then(function () {
				return promisify(fs.readFile)(path.join(v1dir, source)).then(function (v1source) {
					var v2source = _this18.migrateSourcecode(v1source.toString('utf-8'), lib);
					var v2file = path.join(v2dir, source);
					return promisify(fs.writeFile)(v2file, v2source);
				});
			});
		}

		/**
   * Migrates a single example file into a new directory in the v2 space.
   * @param {string} lib       The name of the library being migrated - used to migrate include statements.
   * @param {string} example   The name of the example source file (in the examples folder)
   * @param {string} v1dir     The directory containing the v1 examples
      * @param {string} v2dir     The directory containing the v2 examples
   * @returns {Promise}   The promise to create the output example.
   */

	}, {
		key: 'migrateExample',
		value: function migrateExample(lib, example, v1dir, v2dir) {
			var _this19 = this;

			return this.mkdirIfNeeded(v2dir)
			// read the original example file
			.then(function () {
				return promisify(fs.readFile)(path.join(v1dir, example));
			}).then(function (v1example) {
				var v2example = _this19.migrateSourcecode(v1example.toString('utf-8'), lib);
				var basename = _this19.extension(example)[1];
				var exampledir = path.join(v2dir, basename);
				var examplefile = path.join(exampledir, example);
				return _this19.mkdirIfNeeded(exampledir).then(function () {
					return promisify(fs.writeFile)(examplefile, v2example);
				});
			});
		}

		/**
   * Migrates the examples directory
   * @param {string} libdir    The directory containing the lib to migrate
   * @param {string} name      The name of the lib
   * @return {Promise} to migrate the examples
   * @private
   */

	}, {
		key: 'migrateExamples',
		value: function migrateExamples(libdir, name) {
			var v1 = path.join(libdir, firmwareDir, examplesDir);
			var v2 = path.join(libdir, examplesDir);
			var self = this;
			function mapper(stat, example, filePath) {
				if (stat.isFile()) {
					return self.migrateExample(name, example, path.dirname(filePath), v2);
				} else {
					return mapActionDir(filePath, mapper, function (promises) {
						return promises;
					});
				}
			}

			return this.fileStat(v1).then(function (stat) {
				if (stat) {
					mapActionDir(v1, mapper, function (promises) {
						return promises;
					});
				}
			});
		}
	}, {
		key: 'escapeRegExp',
		value: function escapeRegExp(str) {
			return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
		}

		/**
   * Migrates a C++ source file from v1 to v2 format. The include directives for files matching the pattern
   * #include "libname/rest/of/path" are changed to just #include "rest/of/path" to be compatible with the lib v2
   * layout.
   *
   * @param {string} source The source code to migrate.
   * @param {string} libname  The name of the library to migrate.
   * @returns {string} The transformed source code.
   */

	}, {
		key: 'migrateSourcecode',
		value: function migrateSourcecode(source, libname) {
			var libnameEscape = this.escapeRegExp(libname);
			var find = new RegExp('(#include\\s+[\'"])' + libnameEscape + '[\\/\\\\]', 'g');
			return source.replace(find, function (match, inc) {
				return inc;
			});
		}
	}, {
		key: 'migrateDescriptor',
		value: function migrateDescriptor(desc) {
			if (desc.architectures) {
				desc.architectures = desc.architectures.split(',');
			}
			return desc;
		}
	}, {
		key: '_requireV2Format',
		value: function _requireV2Format(libname) {
			return new _librepo.LibraryRepositoryError(this, 'the library should be in v2 format before adapters can be added.');
		}
	}, {
		key: '_targetDirectoryDoesNotExist',
		value: function _targetDirectoryDoesNotExist(dir) {
			new _librepo.LibraryRepositoryError(this, 'The target directory ' + dir + ' does not exist.');
		}
	}, {
		key: 'addAdapters',
		value: function addAdapters(callback, libname, dir) {
			var _this20 = this;

			return this.getLibraryLayout(libname).then(function (layout) {
				if (layout !== 2) {
					throw _this20._requireV2Format(libname);
				}
				return _this20.fileStat(dir);
			}).then(function (stat) {
				if (stat === null || !stat.isDirectory()) {
					throw _this20._targetDirectoryDoesNotExist(dir);
				}
				return _this20._addAdapters(callback, libname, dir);
			});
		}

		/**
   * Creates files in the given directory that allow the old libname/libname.h include notation
   * to be used.
   * @param {function} callback receives notification of the current progress.
   * @param {string} libname  The library name/identifier. This is used with the naming scheme
   * to determine the library directory in the file system.
   * @param {string} dir the directory in the include path that the files should be copied to. if
   * not defined, the files are copied to the library sources.
   * @returns {Promise} to create the adapter header files.
   */

	}, {
		key: '_addAdapters',
		value: function _addAdapters(callback, libname, dir) {
			var _this21 = this;

			var name = this.namingStrategy.nameToFilesystem(libname);
			var libdir = this.libraryDirectory(name);
			return this.fetch(libname).then(function (lib) {
				var libsrcdir = path.join(libdir, 'src');
				var targetdir = path.join(dir, lib.name);
				return _this21._addAdaptersImpl(callback, targetdir, libsrcdir);
			});
		}
	}, {
		key: 'isHeaderFile',
		value: function isHeaderFile(name) {
			var headers = ['h', 'hxx', 'hpp', 'h++'];
			return headers.indexOf(this.extension(name)[0]) !== -1;
		}

		/**
   * Recursively adds adapter header files from the given source directoyr into the given target directory.
   * @param {function} callback   Notification of header file creation and recursion. (Currently unused.)
   * @param {string} targetdir The directory the header files are created in
   * @param {string} srcdir    The directory containing the existing header files
   * @param {Array<string>} ignore    The current working list of source directories to not copy
   * @returns {undefined} nothing
   * @private
   */

	}, {
		key: '_addAdaptersImpl',
		value: function _addAdaptersImpl(callback, targetdir, srcdir) {
			var ignore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [targetdir];

			var self = this;
			if (!(ignore.indexOf(srcdir) !== -1)) {
				ignore.push(targetdir);
				var writeFile = promisify(fs.writeFile);
				var relative = path.relative(targetdir, srcdir);
				var handleFile = function handleFile(stat, file, filePath) {
					if (stat.isDirectory()) {
						return self._addAdaptersImpl(callback, path.join(targetdir, file), path.join(srcdir, file), ignore);
					} else {
						if (stat.isFile() && self.isHeaderFile(file)) {
							return self.mkdirIfNeeded(targetdir).then(function () {
								return writeFile(path.join(targetdir, file), '#include "' + relative + '/' + file + '"');
							});
						} else {
							return false;
						}
					}
				};

				return mapActionDir(srcdir, handleFile, function () {});
			}
		}
	}, {
		key: 'contribute',
		value: function contribute(name, client, dryRun, callback) {
			var pub = new _libcontribute.LibraryContributor({ repo: this, client: client });
			return pub.contribute(callback, name, dryRun);
		}
	}]);

	return FileSystemLibraryRepository;
}(_librepo.AbstractLibraryRepository);

function isLibraryV2(directory) {
	return new FileSystemLibraryRepository(directory, FileSystemNamingStrategy.DIRECT).getLibraryLayout().then(function (layout) {
		return layout === 2;
	});
}

function normalizeAndSplitPath(p, cwd, absPaths) {
	var abs = path.resolve(cwd, p);
	absPaths.push(abs);
	var stat = fs.statSync(abs);
	if (!stat.isDirectory()) {
		abs = path.dirname(abs);
	}
	var split = abs.split(path.sep);
	return split;
}

function longestArrayCommonPrefix(current, next) {
	if (!current) {
		return next;
	}

	var upper = Math.min(current.length, next.length);
	var i = 0;
	while (i < upper && current[i] === next[i]) {
		i++;
	}
	var prefix = current.slice(0, i);
	return prefix;
}

/**
 * Computes the common prefix of a list of files. Files that are not absolute are made absolute
 * relative to cwd.
 * @param {Array<String>} files the files to find the common prefix of
 * @param {Array<String>} relative optional array that receives the paths relative to the common prefix
 * @param {string} cwd   The directory that relative paths are assumed relative to
 * @return {string} the longest common path prefix
 * If there is no common prefix, the empty string is returned. This can be the case on OSs without
 * a unified filesystem namespace and files are on disjoint paths of the filesystem (e.g. different drives in Windows.)
 *
 * <DANGER: for expediency we are using sync fs functions here. This should only be used
 * from client code: REGNAD>
 */
function pathsCommonPrefix(files) {
	var relative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	var cwd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();


	var result = '';
	if (files.length) {
		var longest = void 0;
		var absFiles = [];
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var _file2 = _step2.value;

				var split = normalizeAndSplitPath(_file2, cwd, absFiles);
				longest = longestArrayCommonPrefix(longest, split);
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		result = longest.join(path.sep);
		if (relative) {
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = absFiles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _file = _step3.value;

					relative.push(path.relative(result, _file));
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}
	}
	return result;
}

/**
 * This computes a mapping between 2 namespaces:
 * - the files as they really exist in the file system (the library v2 format)
 * - the project structure required by the compiler service to build the project.
 *
 * The original namespace is represented by the data members, basePath, libraryPath and example,
 * with libraryPath and example relative to basePath.
 */

var LibraryExample = function () {
	/**
  * The paths are either absolute or relative to basePath
  * @param {string} basePath         The relative directory for all other paths
  * @param {string} libraryPath      The library path relative to the base path
  * @param {string} example          The example path relative to the base path
  */
	function LibraryExample(_ref) {
		var basePath = _ref.basePath,
		    libraryPath = _ref.libraryPath,
		    example = _ref.example;

		_classCallCheck(this, LibraryExample);

		Object.assign(this, { basePath: basePath, libraryPath: libraryPath, example: example });
	}

	/**
  *
  * @param {Object} files `list` - the actual filenames to send, `alias` the filenames as seen by the user, maps each
  *  index to the corresponding file in `list`, `map`. `baseDir` the root directory relative to the filenames in `list`.
  * @returns {Promise} to build the file mapping
  *
  * The library directory is assumed to be the common parent and this is made the base directory.
  *
  */


	_createClass(LibraryExample, [{
		key: 'buildFiles',
		value: function buildFiles(files) {
			// the physical location of files is what is shown in error messages so that they are consistent from the
			// user's working directory
			// The target namespace moves the library.properties into the root as project.properties
			files.list = [];
			files.map = {};
			files.basePath = this.basePath;
			var srcDirectory = this._asDirectory('src');
			var libDirectory = this._asDirectory('lib');

			return Promise.all([
			// add the example file, or the contents of the example directory to 'src' in the target
			this._addFiles(files, this.example, srcDirectory),

			// rename the library to project files
			this._addFiles(files, path.join(this.libraryPath, 'library.properties'), 'project.properties'),

			// copy the library sources into src (potential name-clash with example sources?)
			this._addFiles(files, path.join(this.libraryPath, srcDirectory), srcDirectory, false), this._addFiles(files, path.join(this.libraryPath, libDirectory), libDirectory, false)]);
		}
	}, {
		key: '_asDirectory',
		value: function _asDirectory(p) {
			return this._isFile(p) ? p + path.sep : p;
		}

		/**
   * Adds a mapping. The mapping is from the target file to the source file - that is, the mapping shows all files in the
   * target project, and the corresponding source files where the content can be obtained from.
   * @param {Object} files the file mapping object with a `map` property and `basePath` for defining the logical namespace.
   * @param {String} source The source file relative to `this.basePath`
   * @param {String} target The target file relative to `files.basePath` (the target namespace)
   * @returns {undefined} nothing
   * @private
   */

	}, {
		key: '_addFileMapping',
		value: function _addFileMapping(files, source, target) {
			// given a target file, retrieve the physical file where it lives, relative to this.basePath
			files.map[target] = source;
		}

		/**
   * Adds all the files under the given directory to a mapping recursively.
   * @param {Object} files     The structure to populate. It is updated by calling `_addFileMapping` for each file added.
   * @param {string} source  The path of the files to copy - this part of the path is not featured in the destination path
   * @param {string} destination The path of the destination.
   * @param {string} subdir   The current recursion point below the source folder
   * @returns {Promise} to add a mapping from all files in the source directory to the destination directory
   * @private
   */

	}, {
		key: '_addDirectory',
		value: function _addDirectory(files, source, destination) {
			var subdir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

			function mapper(stat, file, filePath) {
				var traversePath = path.join(subdir, file);
				var sourcePath = path.join(source, traversePath); // the path to the source file
				var destinationPath = path.join(destination, traversePath); // the path to the destination file
				if (stat.isDirectory()) {
					// recurse
					return this._addDirectory(files, source, destination, traversePath);
				} else {
					// add the file - todo should this filter out files like the CLI does?
					this._addFileMapping(files, sourcePath, destinationPath);
				}
			}
			var directory = path.resolve(path.join(files.basePath, source, subdir));
			return mapActionDir(directory, mapper.bind(this), function () {});
		}

		/**
   * Adds files to the file mappings. Directories are indicated by ending with a trailing slash.
   * @param {Files} files     The object that holds the mappings. `basePath` defies the root for the files
   * @param {String} source    The source file or directory, relative to `files.basePath` If it is a file, the file is copied to the destination.
   *  If it is a directory, the directory path is not part of the destination name, only files and subdirectories
   *  under the directory are mapped to the destination path.
   * @param {String} destination   The destination path relative to the target filesystem.
   * @param {boolean} mandatory   When `false` silently returns when the source does not exist
   * @returns {Promise} to add the files to the `files` mapping
   * @private
   */

	}, {
		key: '_addFiles',
		value: function _addFiles(files, source, destination) {
			var _this22 = this;

			var mandatory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			var destinationFile = this._isFile(destination);

			var stat = promisify(fs.stat);

			var promise = stat(path.join(this.basePath, source)).then(function (stat) {
				var sourceFile = stat.isFile();
				// if the source is a file, and the target a directory, compute the full target path.
				if (sourceFile) {
					if (!destinationFile) {
						destination = path.join(destination, source);
					}
					_this22._addFileMapping(files, source, destination);
				} else {
					// assume destination is a directory, since copying a source directory to a file
					// makes little sense here.
					return _this22._addDirectory(files, source, destination);
				}
			});

			if (!mandatory) {
				// chomp chomp
				promise = promise.catch(function (error) {
					return 0;
				});
			}
			return promise;
		}
	}, {
		key: '_isFile',
		value: function _isFile(p) {
			return !p.endsWith(path.sep);
		}
	}]);

	return LibraryExample;
}();

/**
 * Determines if the file represents a library example, and returns a `LibraryExample` instance if it is.
 * @param {String} file The name of the example file or example directory
 * @param {String} cwd The path that `file` is relative to.
 * @returns {*} a falsey value if it is not an example in a v2 library.
 *  otherwise returns a LibraryExample instance.
 */


function isLibraryExample(file) {
	var cwd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();

	var stat = promisify(fs.stat);
	// the directory containing the example
	var examplePath = path.resolve(cwd, file);
	return stat(examplePath).then(function (stat) {
		var directory = stat.isDirectory() ? examplePath : path.resolve(examplePath, '..');
		// the examples directory
		var examplesDirectory = path.resolve(directory, '..');
		// the library directory
		var libraryDirectory = path.resolve(examplesDirectory, '..');
		// `/examples`
		var examplesSingleDir = path.sep + examplesDir;
		// todo - case insensitive comparison on file systems that are case insensitive?
		var isExample = examplesDirectory.endsWith(examplesSingleDir);
		isExample = isExample && isLibraryV2(libraryDirectory).then(function (isV2) {
			if (isV2) {
				return new LibraryExample({
					basePath: cwd,
					libraryPath: path.relative(cwd, libraryDirectory),
					example: file + (stat.isDirectory() ? path.sep : '')
				});
			}
		});
		return isExample;
	});
}

// keep all branches  of the ES6 transpilled code executed
/* istanbul ignore next: not executed on node 7 */

exports.default = function () {};