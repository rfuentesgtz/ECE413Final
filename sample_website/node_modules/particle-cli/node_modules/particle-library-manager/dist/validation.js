'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.validateField = validateField;
exports.validateMetadata = validateMetadata;
exports.validateLibrary = validateLibrary;
exports.formatValidationError = formatValidationError;
exports.formatValidationErrors = formatValidationErrors;
exports.validationMessage = validationMessage;

var _klaw = require('klaw');

var _klaw2 = _interopRequireDefault(_klaw);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /*
                                                                                                                                                                                                                   ******************************************************************************
                                                                                                                                                                                                                   Copyright (c) 2016 Particle Industries, Inc.  All rights reserved.
                                                                                                                                                                                                                  
                                                                                                                                                                                                                   This program is free software; you can redistribute it and/or
                                                                                                                                                                                                                   modify it under the terms of the GNU Lesser General Public
                                                                                                                                                                                                                   License as published by the Free Software Foundation, either
                                                                                                                                                                                                                   version 3 of the License, or (at your option) any later version.
                                                                                                                                                                                                                  
                                                                                                                                                                                                                   This program is distributed in the hope that it will be useful,
                                                                                                                                                                                                                   but WITHOUT ANY WARRANTY; without even the implied warranty of
                                                                                                                                                                                                                   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                                                                                                                                                                                                                   Lesser General Public License for more details.
                                                                                                                                                                                                                  
                                                                                                                                                                                                                   You should have received a copy of the GNU Lesser General Public
                                                                                                                                                                                                                   License along with this program; if not, see <http://www.gnu.org/licenses/>.
                                                                                                                                                                                                                   ******************************************************************************
                                                                                                                                                                                                                   */

var REQUIRED_FIELDS = ['name', 'version', 'author', 'sentence'];

var PATTERNS = {
	name: {
		pattern: /^[A-Za-z0-9][A-Za-z0-9-_\+]*$/,
		message: 'must only contain letters, numbers, dashes, underscores and plus signs.'
	},

	version: {
		pattern: /^\d+\.\d+\.\d+$/,
		message: 'must be formatted like 1.0.0'
	}
};

Object.entries = function (x) {
	return Object.keys(x).reduce(function (y, z) {
		return y.push([z, x[z]]) && y;
	}, []);
};

/**
 * Validate one field of the library metadata
 * @param {string} field - name of the field to validate
 * @param {string} value - value of the field to validate
 * @returns {object} - key valid indicates if validation passed
 *                     key errors is an object with pairs of invalid field names and error messages
 */
function validateField(field, value) {
	if (REQUIRED_FIELDS.indexOf(field) !== -1 && !value) {
		return {
			field: field, value: value,
			valid: false,
			errors: _defineProperty({}, field, "can't be blank")
		};
	}

	var validator = void 0;
	if (validator = PATTERNS[field]) {
		if (!value.match(validator.pattern)) {
			return {
				field: field, value: value,
				valid: false,
				errors: _defineProperty({}, field, validator.message)
			};
		}
	}

	return {
		field: field, value: value,
		valid: true
	};
}

/**
 * Validate the entire library metadata
 * @param {object} metadata - object with all the library fields
 * @returns {object} - key valid indicates if validation passed
 *                     key errors is an object with pairs of invalid field names and error messages
 */
function validateMetadata(metadata) {
	var results = {
		valid: true
	};

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = Object.entries(metadata)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _step$value = _slicedToArray(_step.value, 2),
			    field = _step$value[0],
			    value = _step$value[1];

			var fieldResults = validateField(field, value);

			if (!fieldResults.valid) {
				results.valid = false;
				results.errors = Object.assign({}, results.errors, fieldResults.errors);
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return results;
}

var ValidationFailed = function ValidationFailed(validationResults) {
	_classCallCheck(this, ValidationFailed);

	this.validationResults = validationResults;
	this.name = 'ValidationFailedError';
};

/**
 * Validate the library format, metadata and the file structure
 * @param {object} repo - the library repository that provides access to the library files
 * @param {string} libraryName - the library to validate (defaults to library at the root of the repo)
 * @returns {object} - key valid indicates if validation passed
 *                     key errors is an object with pairs of invalid field names and error messages
 */


function validateLibrary(repo) {
	var libraryName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	// A promise chain that can return early by rejecting with ValidationFailed
	return _validateLibraryLayout(repo, libraryName).then(function () {
		return _validateLibraryMetadata(repo, libraryName);
	}).then(function () {
		return _validateLibraryFiles(repo, libraryName);
	}).then(function () {
		return {
			valid: true
		};
	}).catch(function (error) {
		if (error.name === 'ValidationFailedError') {
			return error.validationResults;
		}
		throw error;
	});
}

function _validateLibraryLayout(repo, libraryName) {
	return repo.getLibraryLayout(libraryName).then(function (layout) {
		if (layout !== 2) {
			throw new ValidationFailed({
				valid: false,
				errors: {
					library: 'must be migrated from v1 format'
				}
			});
		}
	}, function (error) {
		if (error.name === 'LibraryNotFoundError') {
			throw new ValidationFailed({
				valid: false,
				errors: {
					library: 'is missing library.properties'
				}
			});
		}
		throw error;
	});
}

function _validateLibraryMetadata(repo, libraryName) {
	return repo.fetch(libraryName).then(function (library) {
		return library.definition();
	}).then(function (metadata) {
		return validateMetadata(metadata);
	}).then(function (results) {
		if (!results.valid) {
			throw new ValidationFailed(results);
		}
	});
}

/**
 * Enumerate all files relative to the root of the library
 * @param {string} directory - root of the library
 * @returns {Promise} - resolves to array of relative paths
 * @private
 */
function _libraryFiles(directory) {
	return new Promise(function (fulfill) {
		var files = [];
		(0, _klaw2.default)(directory).on('data', function (item) {
			var relativePath = _path2.default.relative(directory, item.path);
			files.push(relativePath);
		}).on('end', function () {
			fulfill(files);
		});
	});
}

function _mainSourceName(repo, libraryName) {
	return repo.fetch(libraryName).then(function (library) {
		return library.definition();
	}).then(function (metadata) {
		return metadata.name;
	});
}

/**
 * Validate that README, LICENSE and src/lib.cpp and src/lib.h are present
 * @param {object} repo - filesystem library repo
 * @param {string} libraryName - name of library in the filesystem repo
 * @returns {Promise} - object with valid and errors keys
 * @private
 */
function _validateLibraryFiles(repo, libraryName) {
	var results = {
		valid: true
	};

	var directory = repo.libraryDirectory(libraryName);

	var requiredFiles = {
		'README.md': /^README/i,
		'LICENSE': /^LICENSE/i
	};

	return _mainSourceName(repo, libraryName).then(function (mainSourceName) {
		// Match Windows and UNIX paths
		// todo - factor out the regex (it's copied from PATTERNS.name.pattern without the start/end match)
		//requiredFiles['main source'] = new RegExp('src[/\\\\][A-Za-z0-9][A-Za-z0-9-_\+]*.cpp', 'i');
		requiredFiles['main header'] = new RegExp('src[/\\\\][A-Za-z0-9][A-Za-z0-9-_\+]*.h', 'i');
	}).then(function () {
		return _libraryFiles(directory);
	}).then(function (files) {
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			var _loop = function _loop() {
				var _step2$value = _slicedToArray(_step2.value, 2),
				    requiredFile = _step2$value[0],
				    filenamePattern = _step2$value[1];

				if (!files.find(function (f) {
					return f.match(filenamePattern);
				})) {
					results.valid = false;
					results.errors = Object.assign({}, results.errors, _defineProperty({}, requiredFile, 'is missing'));
				}
			};

			for (var _iterator2 = Object.entries(requiredFiles)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				_loop();
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		if (!results.valid) {
			throw new ValidationFailed(results);
		}
	});
}

function formatValidationError(key, message) {
	return key + ' ' + message;
}

function formatValidationErrors(results) {
	var errors = [];
	for (var key in results.errors) {
		var value = results.errors[key];
		errors.push(formatValidationError(key, value));
	}
	return errors;
}

function validationMessage(results) {
	var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '\n';

	return formatValidationErrors(results).join(separator);
}